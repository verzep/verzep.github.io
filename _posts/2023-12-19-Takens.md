---
layout: post
title: "Delays are all you need -5"
tags: dynamical_systems, neural_networks
category: machine_learning
---

When dealing with dynamical systems, one usually faces the problem of partially-observed data.
The engineering literature deals a lot with partially-observed linear dynamical systems, but do we have any hope to make predictions when our system is nonlinear?
To answer this question, we will have to discuss one of the most amazing results in this context: Takens's theorem, which actually allow us to give a positive answer to this question.

In this post, I'll quickly discuss this fundamental theorem and show how we can use it to predict dynamical systems, providing some coding examples in `Python` (using also `scikit-learn` and `Pytorch`) to guide you through it.

## Stating the Problem

Let us consider a (possibly nonlinear) dynamical system, which we write of the form:

\begin{equation}\label{eqn:takens_source}
  s_{t} =  g(s_{t-1}) 
\end{equation}

For example, we can use the Lorenz system as in the previous example.

```python

# Define the Lorenz system of differential equations
def lorenz(t, y, sigma, rho, beta):
    dydt = [sigma * (y[1] - y[0]),
            y[0] * (rho - y[2]) - y[1],
            y[0] * y[1] - beta * y[2]]
    return dydt

# Set the parameters
sigma = 10.0
rho = 28.0
beta = 8.0 / 3.0

# Set the initial conditions
initial_conditions = [1.0, 0.0, 20.0]

# Set the time span for integration
t_span = (0, 100)
t_eval = np.linspace(t_span[0], t_span[1], 12000)

# Solve the system of differential equations
sol = solve_ivp(lorenz, t_span, initial_conditions, args=(sigma, rho, beta), t_eval=t_eval)
```
        
You may argue that the Lorenz System is continuous-time dynamical system, but as discussed [here](https://verzep.github.io/Dynamical-Systems/) one can always construct a discrete-time dynamical system starting from that:
in fact, everytime you measure a system, you'll always deal with discrete observations in time.
Let's now plot one orbit and recognize the famous attractor.


![]({{ site.url }}/images/2023-12-19/Lorenz_attractor.png)

## Observables
Usually things get even more complicated when dealing with real systems.
For example, in many applications it happens that we do not have access to the full state of the system, but only to an observation of its state.

\begin{equation}\label{eqn:takens_observable}
    u_{t}= h(s_{t})
\end{equation}

where we call $u_t$ the _observable_.  Each orbit of \eqref{eqn:takens_source} {$s_t$} corresponds to a time realization of \eqref{eqn:takens_observable} {$u_t$}.
In this post, we consider the symple case in which $u_t$ is simply one of the coordinates ($x$) of the Lorenz System.
    
```python
    # Extract the x-coordinate (u)
    u = sol.y[0]
    
    #create train and test
    u_train = u[500:10000] # we discard some initial points
    u_test = u[10000:]
```
In this case, the data at our disposal looks like this:

![]({{ site.url }}/images/2023-12-19/Lorenz_projection.png)

## TAKENS'S THEOREM

Since \eqref{eqn:takens_source} is an _autonomous system_, the initial condition $s_{t_{0}}$ determines the entire evolution of the system and, consequently, the entire realization of the observable. 
This means that the entire sequence {${u}_t$} depends on the initial condition, in the sense that different initial conditions will lead to different state sequences. 

We now wonder whether the opposite is true or not, i.e., _if one can reconstruct the state of the system by observing a series of one-dimensional measures like \eqref{eqn:takens_observable}.  
Takens's theorem deals with this question.
In order to state the theorem, we now introduce a _delay vector_  $x_t$ constructed from the observation of our dynamical system as:
    
\begin{equation}\label{eqn:takens_function}
 x_t=
    \begin{bmatrix}
    x^1_t \\
    x^2_t\\
    \dots \\
    x^D_t
\end{bmatrix}
=
\begin{bmatrix}
    u_t \\
    u_{t-1}\\
    \dots \\
    u_{t-(D-1)}
\end{bmatrix}
=
\begin{bmatrix}
    h( s_t) \\
    h( s_{t-1})\\
    \dots \\
    h( s_{t-(D-1)})
\end{bmatrix}
=:  {F}_D( s_t)
\end{equation}